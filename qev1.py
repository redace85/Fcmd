#!/usr/bin/env python3.7
# coding=utf-8
import asyncio
import signal
import logging
import sys
import multiprocessing


class QuantEngine():

    #
    # Feeder process function
    #
    def feeder_process(self, strategy_obj, mq):

        from wsfcoinfeeder import WSFcoinFeeder
        import config
        import time

        async def async_f(elp):
            wsfeeder = WSFcoinFeeder(elp, config.proxy)
            while True:
                # never stop feeder
                await wsfeeder.con_sub(strategy_obj.topic)
                async for jo in wsfeeder.feed_stream():
                    d = {'t': 'feeder', 'd': strategy_obj.reform_data(jo)}
                    mq.put(d)

            await wsfeeder.close()

        eloop = asyncio.get_event_loop()
        try:
            eloop.run_until_complete(async_f(eloop))
        except Exception as e:
            logging.error('Catched and exit:', e)
            # feeder err
            x = {'t': 'feeder', 'd': 'err'}
            mq.put(x)

    #
    # Strategies process function
    #
    # mq message format {
    # 't'(type), - feeder, exeback
    # 'd'(data), - user defined data handle in this process
    # }
    #
    def strategies_process(self, strategy_obj, mq, s_pip):

        # reset sigint handler cancel all order when terminate
        def sigint_handler(n, f):
            logging.warning('sigint cancel order...')

            # clean cmd
            sig_ol = strategy_obj.clean_excmd()
            # terminate signal at the end
            sig_ol.append({'o': 'x', 'p': -1, 'd': 'sigint'})
            s_pip.send(sig_ol)
            logging.info('waiting 4 feeder signal...')

        # reset parent process signal handler
        signal.signal(signal.SIGINT, sigint_handler)

        non_feeder_buffer = []
        p_running = True
        while p_running:
            d = mq.get()
            # feeder err
            if d['t'] == 'feeder' and d['d'] == 'err':
                # clean cmd
                cls_ol = strategy_obj.clean_excmd()
                # terminate signal at the end
                cls_ol.append({'o': 'x', 'p': -1, 'd': 'feeder_err'})
                s_pip.send(cls_ol)
                continue
            while not mq.empty() and d['t'] == 'feeder':
                # only lastest feeder msg matters
                peek_data = mq.get()
                if peek_data['t'] != 'feeder':
                    non_feeder_buffer.append(peek_data)
                else:
                    logging.info('!!!newer d replaced')
                    d = peek_data

            if non_feeder_buffer:
                logging.info('non_feeder_buffer refill')
                for b in non_feeder_buffer:
                    mq.put(b)
                non_feeder_buffer.clear()

            if d['t'] == 'feeder':
                order_list = strategy_obj.generate_excmd_from_feeder_data(d)
                if order_list:
                    s_pip.send(order_list)

            elif d['t'] == 'exeback':
                # exeback d format [{
                # 'p'(positon) - generated by strategies comp
                # 'o'(operation), - c(order create), s(submit_cancel), q(query)
                # 'r'(result), - data structure depends on operation
                # }...]
                for order_result in d['d']:
                    p_running &= strategy_obj.update_status_from_exeback(
                        order_result)

    #
    # executor process function
    #
    # pip message format [{
    # 'p'(positon) - generated by strategies comp
    # 'o'(operation), - c(order create), s(submit_cancel), q(query), x(terminate)
    # 'd'(data), - user defined data handle in this process (op, price, volume)
    # }...]
    #
    def executor_process(self, strategy_obj, mq, r_pip):
        import engine_executors

        elp = asyncio.get_event_loop()
        if strategy_obj.whether_mock_trading:
            executor = engine_executors.MockExecutor(elp)
        else:
            executor = engine_executors.FcoinExecutor(elp)
        # order buffer {pos:id}
        s_order_buffer = {}

        while True:
            order_res_list = []
            ol = r_pip.recv()
            logging.info('exe_recv:{}'.format(ol))
            for o in ol:
                o_res = {}
                o_res['p'] = o['p']
                o_res['o'] = o['o']

                if 's' == o['o']:
                    # submit cancel
                    if o['p'] not in s_order_buffer:
                        o_res['r'] = False
                    else:
                        o_res['r'] = executor.submit_cancel(
                            s_order_buffer[o['p']])
                elif 'c' == o['o']:
                    (b_res, order_id) = executor.create_order(
                        strategy_obj.symbol, *(o['d']))
                    if b_res:
                        s_order_buffer[o['p']] = order_id
                    o_res['r'] = b_res

                elif 'q' == o['o']:
                    if o['p'] not in s_order_buffer:
                        o_res['r'] = False
                    else:
                        o_res['r'] = executor.query_order_state(
                            s_order_buffer[o['p']])
                elif 'x' == o['o']:
                    o_res['r'] = o['d']
                order_res_list.append(o_res)

            d = {'t': 'exeback', 'd': order_res_list}
            mq.put(d)

    def __init__(self, strategy_obj):
        # all children processes ignore sigint
        signal.signal(signal.SIGINT, signal.SIG_IGN)

        mq = multiprocessing.Queue(9)
        r_p, s_p = multiprocessing.Pipe(False)

        self.feeder_p = multiprocessing.Process(name='qe_feeder',
                                                target=self.feeder_process, args=(strategy_obj, mq))
        self.strategies_p = multiprocessing.Process(name='qe_strategies',
                                                    target=self.strategies_process, args=(strategy_obj, mq, s_p))
        self.executor_p = multiprocessing.Process(name='qe_executor',
                                                  target=self.executor_process, args=(strategy_obj, mq, r_p))

        logging.info('engine construction finished')

    def run(self):
        logging.info('engine startup suceed...')
        self.feeder_p.start()
        self.strategies_p.start()
        self.executor_p.start()
        # join forever
        self.strategies_p.join()
        self.feeder_p.terminate()
        self.executor_p.terminate()
        logging.info('engine terminated')


if __name__ == '__main__':
    '''
    the previous engine names~~

    pt1engin: prototype qe
    pt2engin: prototype qe
    V1: first version of qe
    '''
    print('This is the V1A1 quantitive engine~')
    use_stdout = False
    if not use_stdout:
        stream = open('qev1.log',mode='w')
    else:
        stream = sys.stdout
    logging.basicConfig(stream = stream,
                        format='%(levelname)s:%(message)s', level=logging.INFO)

    import strategy_pos

    strategy_obj = strategy_pos.Position_Strategy(mock=True)
    strategy_obj.init_strategy_data()

    qe = QuantEngine(strategy_obj)
    qe.run()