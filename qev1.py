#!/usr/bin/env python3.7
# coding=utf-8
import asyncio
import signal
import logging
import sys
import os
import multiprocessing
import socket


class QuantEngine():
    '''
    the previous engine names~~

    pt1engin: prototype qe
    pt2engin: prototype qe
    V1: first version of qe

    This is the V1A3 quantitive engine~
    '''

    #
    # Feeder process function
    #
    def feeder_process(self, strategy_obj, mq):

        from wsfcoinfeeder import WSFcoinFeeder
        import time

        async def async_f(elp):
            wsfeeder = WSFcoinFeeder(elp)
            while True:
                # never stop feeder
                await wsfeeder.con_sub(strategy_obj.topic)
                try:
                    async for jo in wsfeeder.feed_stream():
                        d = {'t': 'feeder', 'd': strategy_obj.reform_data(jo)}
                        mq.put(d)
                except TimeoutError:
                    logging.error('system timeout, retrying...')

            await wsfeeder.close()

        eloop = asyncio.get_event_loop()
        try:
            eloop.run_until_complete(async_f(eloop))
        except Exception as e:
            logging.error('Catched and exit:{}'.format(e))
            # feeder err
            x = {'t': 'feeder', 'd': 'err'}
            mq.put(x)

    #
    # Strategies process function
    #
    # mq message format {
    # 't'(type), - feeder, exeback, sigint
    # 'd'(data), - user defined data handle in this process
    # }
    #
    def strategies_process(self, strategy_obj, mq, s_pip):
        # send init cmd
        init_ol = strategy_obj.init_excmd()
        if init_ol:
            s_pip.send(init_ol)
            logging.info('init excmd sent')

        non_feeder_buffer = []
        p_running = True
        while p_running:
            d = mq.get()
            # feeder err
            if d['t'] == 'feeder' and d['d'] == 'err':
                logging.error('feeder_err received')
                # clean cmd
                cls_ol = strategy_obj.clean_excmd()
                # terminate signal at the end
                cls_ol.append({'o': 'x', 'p': -1, 'd': 'feeder_err'})
                s_pip.send(cls_ol)
                continue
            if d['t'] == 'ipc':
                logging.info('ipc received')
                if 'stop' == d['d']:
                    logging.warning('ipc_stop')
                    # clean cmd
                    stop_ol = strategy_obj.clean_excmd()
                    stop_ol.append({'o': 'x', 'p': -1, 'd': 'ipc_stop'})
                    s_pip.send(stop_ol)
                    logging.info('waiting 4 ipc_stop back...')

            while not mq.empty() and d['t'] == 'feeder':
                # only lastest feeder msg matters
                peek_data = mq.get()
                if peek_data['t'] != 'feeder':
                    non_feeder_buffer.append(peek_data)
                else:
                    logging.info('!!!newer d replaced')
                    d = peek_data

            if non_feeder_buffer:
                logging.info('non_feeder_buffer refill')
                for b in non_feeder_buffer:
                    mq.put(b)
                non_feeder_buffer.clear()

            if d['t'] == 'feeder':
                order_list = strategy_obj.generate_excmd_from_feeder_data(d['d'])
                if order_list:
                    s_pip.send(order_list)

            elif d['t'] == 'exeback':
                # exeback d format [{
                # 'p'(positon) - generated by strategies comp
                # 'o'(operation), - c(order create), s(submit_cancel), q(query)
                # 'r'(result), - data structure depends on operation
                # }...]
                for order_result in d['d']:
                    p_running &= strategy_obj.update_status_from_exeback(
                        order_result)

    #
    # executor process function
    #
    # pip message format [{
    # 'p'(positon) - generated by strategies comp
    # 'o'(operation), - c(order create), s(submit_cancel), q(query), x(terminate)
    # 'd'(data), - user defined data handle in this process (op, price, volume)
    # }...]
    #
    def executor_process(self, mq, r_pip, mock_execution):
        from fcoin_executor import FcoinExecutor

        elp = asyncio.get_event_loop()
        executor = FcoinExecutor(elp, mock_execution)
        # order buffer {pos:id}
        s_order_buffer = {}

        while True:
            order_res_list = []
            # hold for income excmd
            ol = r_pip.recv()
            logging.info('exe_recv:{}'.format(ol))
            for o in ol:
                o_res = {}
                o_res['p'] = o['p']
                o_res['o'] = o['o']

                if 's' == o['o']:
                    # submit cancel
                    if o['p'] not in s_order_buffer:
                        o_res['r'] = (False,'pos not found')
                    else:
                        exe_res = executor.submit_cancel(
                            s_order_buffer[o['p']])
                    o_res['r'] = (exe_res,None)
                elif 'c' == o['o']:
                    # create order
                    (b_res, order_id) = executor.create_order(
                        *(o['d']))
                    if b_res:
                        s_order_buffer[o['p']] = order_id
                    o_res['r'] = (b_res, order_id)

                elif 'q' == o['o']:
                    # d: [dp,symbol], [tb,sym...], [or]
                    if 'dp' == o['d'][0]:
                        o_res['r'] = (o['d'][0],
                                      executor.query_dp_l20(o['d'][1]))
                    elif 'tb' == o['d'][0]:
                        o_res['r'] = (o['d'][0],
                                      executor.query_available_tb(o['d'][1:]))

                    elif 'or' == o['d'][0]:
                        if o['p'] not in s_order_buffer:
                            o_res['r'] = (False, 'id not exist')
                        else:
                            o_res['r'] = (o['d'][0],
                                          executor.query_order(
                                s_order_buffer[o['p']]))

                elif 'x' == o['o'] or 'u' == o['o']:
                    # no handle excmd 'x':terminate 'u':state update
                    o_res['r'] = o['d']

                order_res_list.append(o_res)

            d = {'t': 'exeback', 'd': order_res_list}
            mq.put(d)

    def __init__(self, strategy_obj, proxy=None, mock_execution=False):
        # all children processes ignore sigint
        #signal.signal(signal.SIGINT, signal.SIG_IGN)

        mq = multiprocessing.Queue(9)
        r_p, s_p = multiprocessing.Pipe(False)

        self.feeder_p = multiprocessing.Process(name='qe_feeder',
                                                target=self.feeder_process, args=(strategy_obj, mq))
        self.strategies_p = multiprocessing.Process(name='qe_strategies',
                                                    target=self.strategies_process, args=(strategy_obj, mq, s_p))
        self.executor_p = multiprocessing.Process(name='qe_executor',
                                                  target=self.executor_process, args=(mq, r_p, mock_execution))
        self.mq = mq
        logging.info('engine construction finished')

    def run(self, ipc_path):
        self.feeder_p.start()
        self.strategies_p.start()
        self.executor_p.start()
        logging.info('engine startup suceed...')

        # ipc loop
        self._ipc_loop(ipc_path)

        # join forever
        if self.strategies_p.is_alive():
            logging.info('join strategies_p')
            self.strategies_p.join()
        else:
            logging.warning('!strategies_p not alive!')

        self.feeder_p.terminate()
        self.executor_p.terminate()

        os.unlink(ipc_path)
        logging.info('engine terminated')

    def _ipc_loop(self, ipc_path):
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.bind(ipc_path)

        # Listen for incoming connections
        sock.listen(1)

        while True:
            connection, _ = sock.accept()
            try:
                data = connection.recv(32)
                if data:
                    cmd_str = data.decode('utf-8')
                    logging.info('recv ipc cmd:{}'.format(cmd_str))

                    if 'stop' == cmd_str:
                        # exit clean up
                        logging.warning('engine ipc stop~')
                        x = {'t': 'ipc', 'd': 'stop'}
                        self.mq.put(x)
                        break
                else:
                    # no more data
                    logging.error('no ipc cmd received!')
            finally:
                # Clean up the connection
                connection.close()
